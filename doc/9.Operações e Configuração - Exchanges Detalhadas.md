### Operações e Configuração: Exchanges Detalhadas

#### Direct Exchange

Uma `Direct Exchange` roteia mensagens para as filas com base na chave de roteamento (routing key). Apenas as filas que têm uma chave de binding que corresponde exatamente à chave de roteamento da mensagem receberão a mensagem.

**Exemplo em Node.js**:

1. **Produtor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'direct_logs';
       const msg = 'Hello World!';
       const severity = 'info';

       channel.assertExchange(exchange, 'direct', {
         durable: false
       });
       channel.publish(exchange, severity, Buffer.from(msg));
       console.log(" [x] Sent %s: '%s'", severity, msg);
     });

     setTimeout(function() {
       connection.close();
       process.exit(0);
     }, 500);
   });
   ```

2. **Consumidor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'direct_logs';
       const args = process.argv.slice(2);
       const severity = args.length > 0 ? args[0] : 'info';

       channel.assertExchange(exchange, 'direct', {
         durable: false
       });

       channel.assertQueue('', {
         exclusive: true
       }, function(error2, q) {
         if (error2) {
           throw error2;
         }
         console.log(" [*] Waiting for logs. To exit press CTRL+C");

         channel.bindQueue(q.queue, exchange, severity);

         channel.consume(q.queue, function(msg) {
           if (msg.content) {
             console.log(" [x] %s: '%s'", msg.fields.routingKey, msg.content.toString());
           }
         }, {
           noAck: true
         });
       });
     });
   });
   ```

#### Fanout Exchange

Uma `Fanout Exchange` roteia mensagens para todas as filas que estão ligadas a ela, independentemente da chave de roteamento.

**Exemplo em Node.js**:

1. **Produtor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'logs';
       const msg = 'Hello World!';

       channel.assertExchange(exchange, 'fanout', {
         durable: false
       });
       channel.publish(exchange, '', Buffer.from(msg));
       console.log(" [x] Sent '%s'", msg);
     });

     setTimeout(function() {
       connection.close();
       process.exit(0);
     }, 500);
   });
   ```

2. **Consumidor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'logs';

       channel.assertExchange(exchange, 'fanout', {
         durable: false
       });

       channel.assertQueue('', {
         exclusive: true
       }, function(error2, q) {
         if (error2) {
           throw error2;
         }
         console.log(" [*] Waiting for messages in %s. To exit press CTRL+C", q.queue);

         channel.bindQueue(q.queue, exchange, '');

         channel.consume(q.queue, function(msg) {
           if (msg.content) {
             console.log(" [x] %s", msg.content.toString());
           }
         }, {
           noAck: true
         });
       });
     });
   });
   ```

#### Topic Exchange

Uma `Topic Exchange` roteia mensagens para as filas com base em padrões de chaves de roteamento, utilizando curingas como `*` (corresponde a uma palavra) e `#` (corresponde a zero ou mais palavras).

**Exemplo em Node.js**:

1. **Produtor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'topic_logs';
       const args = process.argv.slice(2);
       const key = (args.length > 0) ? args[0] : 'anonymous.info';
       const msg = args.slice(1).join(' ') || 'Hello World!';

       channel.assertExchange(exchange, 'topic', {
         durable: false
       });
       channel.publish(exchange, key, Buffer.from(msg));
       console.log(" [x] Sent %s: '%s'", key, msg);
     });

     setTimeout(function() {
       connection.close();
       process.exit(0);
     }, 500);
   });
   ```

2. **Consumidor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'topic_logs';
       const args = process.argv.slice(2);
       const key = (args.length > 0) ? args[0] : '#';

       channel.assertExchange(exchange, 'topic', {
         durable: false
       });

       channel.assertQueue('', {
         exclusive: true
       }, function(error2, q) {
         if (error2) {
           throw error2;
         }
         console.log(" [*] Waiting for messages in %s. To exit press CTRL+C", q.queue);

         channel.bindQueue(q.queue, exchange, key);

         channel.consume(q.queue, function(msg) {
           if (msg.content) {
             console.log(" [x] %s: '%s'", msg.fields.routingKey, msg.content.toString());
           }
         }, {
           noAck: true
         });
       });
     });
   });
   ```

#### Headers Exchange

Uma `Headers Exchange` utiliza cabeçalhos das mensagens em vez das chaves de roteamento para determinar o destino das mensagens. Isso permite um roteamento mais flexível e baseado em múltiplos atributos.

**Exemplo em Node.js**:

1. **Produtor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'headers_logs';
       const msg = 'Hello World!';
       const headers = {
         'format': 'pdf',
         'type': 'report'
       };

       channel.assertExchange(exchange, 'headers', {
         durable: false
       });
       channel.publish(exchange, '', Buffer.from(msg), { headers });
       console.log(" [x] Sent '%s'", msg);
     });

     setTimeout(function() {
       connection.close();
       process.exit(0);
     }, 500);
   });
   ```

2. **Consumidor**:
   ```javascript
   const amqp = require('amqplib/callback_api');

   amqp.connect('amqp://localhost', function(error0, connection) {
     if (error0) {
       throw error0;
     }
     connection.createChannel(function(error1, channel) {
       if (error1) {
         throw error1;
       }
       const exchange = 'headers_logs';

       channel.assertExchange(exchange, 'headers', {
         durable: false
       });

       channel.assertQueue('', {
         exclusive: true
       }, function(error2, q) {
         if (error2) {
           throw error2;
         }
         console.log(" [*] Waiting for messages in %s. To exit press CTRL+C", q.queue);

         channel.bindQueue(q.queue, exchange, '', {
           'x-match': 'all',
           'format': 'pdf',
           'type': 'report'
         });

         channel.consume(q.queue, function(msg) {
           if (msg.content) {
             console.log(" [x] %s", msg.content.toString());
           }
         }, {
           noAck: true
         });
       });
     });
   });
   ```

---

Esses exemplos mostram como configurar e utilizar diferentes tipos de exchanges no RabbitMQ usando Node.js. Cada tipo de exchange oferece uma maneira diferente de roteamento de mensagens, permitindo flexibilidade para atender às necessidades específicas de suas aplicações.